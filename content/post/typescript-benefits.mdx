---
title: "TypeScript and MDX: Building Type-Safe Content with Next.js"
date: "2024-03-19"
description: "Explore how TypeScript enhances Next.js development with type safety, autocomplete, and build-time validation. Learn about content transformation with rehype plugins."
tags: ["typescript", "nextjs", "development", "mdx"]
summary: "A dive into the TypeScript benefits in Next.js"
category: "coding"
readingTime: 10
---

# TypeScript and MDX: Building Type-Safe Content with Next.js

TypeScript has become the de facto standard for building large-scale Next.js applications. In this post, we'll explore how TypeScript enhances the development experience, particularly when working with content management systems like ContentLayer.

## Type Safety: More Than Just Type Checking

TypeScript's primary benefit is type safety, but what does that mean in practice? Let's look at how it helps prevent runtime errors and improves code quality.

### 1. Autocomplete and IntelliSense

One of the most immediate benefits of TypeScript is enhanced IDE support. When working with ContentLayer, you get automatic type definitions for your content:

```typescript
// ContentLayer automatically generates types for your content
import { Post } from 'contentlayer/generated'

// Your IDE now knows exactly what properties are available
const post: Post = {
  title: "My Blog Post",
  date: "2024-03-19",
  description: "A great post",
  // TypeScript will show an error if you miss required fields
  // or try to add fields that don't exist
}
```

The autocomplete feature shows you:
- Available properties
- Correct types for each property
- Required vs optional fields
- Available methods and functions

### 2. Type Checking During Development

TypeScript catches errors before your code runs. Here's a practical example:

```typescript
// Without TypeScript
function getPostDate(post) {
  return post.date.toUpperCase() // This might fail at runtime if date is undefined
}

// With TypeScript
function getPostDate(post: Post) {
  return post.date.toUpperCase() // TypeScript error: Property 'toUpperCase' doesn't exist on type 'string'
}
```

TypeScript helps you:
- Catch null/undefined errors
- Ensure correct property access
- Validate function parameters
- Prevent type mismatches

### 3. Build-Time Validation

TypeScript's type checking happens during development and build time:

```typescript
// This will fail during build
const invalidPost: Post = {
  title: 123, // Error: Type 'number' is not assignable to type 'string'
  date: "2024-03-19",
  description: "A great post"
}
```

## Content Transformation with Rehype

Rehype plugins transform your content during the build process. Let's explore two popular approaches:

### 1. rehype-prism-plus: Simple and Efficient

rehype-prism-plus is a lightweight solution that uses Prism.js for syntax highlighting:

```markdown
# Original MDX content
```javascript
const greeting = "Hello, World!";
console.log(greeting);
```

When processed by rehype-prism-plus, it becomes:

```html
<pre class="language-javascript">
  <code class="language-javascript">
    <span class="token keyword">const</span> 
    <span class="token variable">greeting</span> 
    <span class="token operator">=</span> 
    <span class="token string">"Hello, World!"</span>;
    <span class="token function">console</span>.
    <span class="token function">log</span>
    <span class="token punctuation">(</span>
    <span class="token variable">greeting</span>
    <span class="token punctuation">)</span>;
  </code>
</pre>
```

Benefits of rehype-prism-plus:
- Lightweight and fast
- Simple configuration
- Standard token-based highlighting
- Excellent performance

### 2. rehype-pretty-code: Feature-Rich Alternative

rehype-pretty-code offers more advanced features:

```typescript
// Configuration example
const prettyCodeOptions = {
  theme: 'github-dark',
  onVisitLine(node) {
    if (node.children.length === 0) {
      node.children = [{ type: 'text', value: ' ' }];
    }
  },
  onVisitHighlightedLine(node) {
    node.properties.className.push('highlighted');
  },
  onVisitHighlightedWord(node) {
    node.properties.className = ['word'];
  }
};
```

Features of rehype-pretty-code:
- Line highlighting
- Word highlighting
- Line numbers
- Custom themes
- More configuration options

### Choosing Between the Two

The choice between these plugins depends on your needs:

- Use **rehype-prism-plus** if you want:
  - Simple, reliable syntax highlighting
  - Fast build times
  - Standard token-based styling
  - Minimal configuration

- Use **rehype-pretty-code** if you need:
  - Advanced features like line highlighting
  - Custom themes
  - More styling options
  - Don't mind slightly more complex setup

## Code Block Handling in MDX

When working with code in MDX, we need to handle two different types of code elements:

### Inline Code vs Code Blocks

MDX supports two ways to include code:

1. **Inline Code** (single backticks):
```markdown
This is an inline `code` example.
```

2. **Code Blocks** (triple backticks):
```markdown
```javascript
const greeting = "Hello";
console.log(greeting);
```
```

These are handled differently in our MDX components:

```typescript
code: ({ className, children, ...props }) => {
  // For inline code: Simple styling
  if (!className?.includes('language-')) {
    return (
      <code className="relative rounded bg-slate-100 px-[0.3rem] py-[0.2rem] font-mono text-sm text-[#FF6F61]">
        {children}
      </code>
    );
  }

  // For code blocks: Syntax highlighting
  return (
    <code className={cn(className, "text-white")} {...props}>
      {children}
    </code>
  );
}
```

### Language Badges

Code blocks can include a language badge in the top-right corner:

```typescript
{language !== 'text' && (
  <div className="absolute right-3 top-0 z-[1] rounded-b-sm bg-slate-700 px-2 py-0.5 text-xs font-medium text-white">
    {language}
  </div>
)}
```

We only show the language badge when `language !== 'text'` because:
- Plain text code blocks don't need a language indicator
- It would be redundant to show a "text" badge
- The badge is most useful for actual programming languages

## Next.js Content Loading Strategies

When working with MDX content in Next.js, we have several options for loading and rendering content:

### Static Generation

Next.js provides powerful static generation capabilities that work well with MDX content:

```typescript
// pages/posts/[slug].tsx
export async function getStaticPaths() {
  const posts = allPosts
  return {
    paths: posts.map((post) => ({
      params: { slug: post.slug }
    }))
  }
}

export async function getStaticProps({ params }) {
  const post = allPosts.find((post) => post.slug === params.slug)
  return { props: { post } }
}
```

This approach:
- Generates all pages at build time
- Provides the best performance
- Enables static hosting
- Works perfectly with MDX content

### Rendering Strategies Comparison

Next.js offers different rendering strategies:

1. **Static Generation (SSG)**
   - Pages are generated at build time
   - Best performance
   - Content is available immediately
   - Perfect for MDX blog posts

2. **Server-Side Rendering (SSR)**
   - Pages are generated on each request
   - Good for dynamic content
   - Higher server load
   - Not ideal for static MDX content

3. **Client-Side Loading**
   - Content is fetched after page load
   - Higher initial load time
   - More flexible for dynamic content
   - Not recommended for MDX content

<Callout type="tip">
  For MDX content, Static Generation is the recommended approach as it provides the best performance and user experience.
</Callout>

## TypeScript Interfaces in React Components

TypeScript interfaces play a crucial role in React component development. Let's explore why and how to use them effectively.

### Why Use Interfaces?

Interfaces provide several key benefits:

1. **Type Safety**
```typescript
// Without interface
const Component = ({ title, date }) => { ... }  // No type checking!

// With interface
interface ComponentProps {
  title: string;
  date: Date;
}
const Component = ({ title, date }: ComponentProps) => { ... }  // TypeScript will catch errors
```

2. **Documentation**
```typescript
interface PostProps {
  title: string;      // Required title
  date?: Date;        // Optional date
  tags: string[];     // Array of tags
  author: {           // Nested object
    name: string;
    role: string;
  };
}
```
The interface serves as self-documenting code, making it clear what props the component expects.

3. **Reusability**
```typescript
// Can be reused across components
interface BaseCardProps {
  className?: string;
  children: React.ReactNode;
}

// Extended for specific use cases
interface BlogCardProps extends BaseCardProps {
  title: string;
  excerpt: string;
}
```

### When to Use Interfaces

#### Use Interfaces For:
- Public components
- Complex props
- Reusable components
- Components with multiple props

#### Consider Inline Types For:
- Very simple components
- Single-prop components
- Internal/private components

### Best Practices

1. **Define Required vs Optional Props**
```typescript
interface Props {
  required: string;    // Required prop
  optional?: string;   // Optional prop
  default?: number;    // Optional with default value
}
```

2. **Specify Prop Types**
```typescript
interface ComponentProps {
  text: string;           // String
  count: number;          // Number
  isActive: boolean;      // Boolean
  items: string[];        // Array
  config: {               // Object
    theme: string;
    size: number;
  };
}
```

3. **Document Component APIs**
```typescript
interface CardProps {
  /** The title of the card */
  title: string;
  /** Optional description text */
  description?: string;
  /** Array of tags to display */
  tags: string[];
  /** Callback when card is clicked */
  onClick?: () => void;
}
```

<Callout type="tip">
  While interfaces are generally recommended, use your judgment. For very simple components or internal utilities, inline types might be more appropriate.
</Callout>

## Next.js Project Structure and Routing

A well-organized project structure is crucial for maintainability and scalability. Let's explore the recommended structure for a Next.js application with MDX content.

### Recommended Directory Structure

```
/
├── src/
│   ├── app/                    # Next.js app directory
│   │   ├── (routes)/          # Route groups for better organization
│   │   │   ├── post/         # Blog post routes
│   │   │   ├── projects/     # Project routes
│   │   │   └── logs/         # Development log routes
│   │   ├── layout.tsx        # Root layout
│   │   └── page.tsx          # Home page
│   ├── components/           # React components
│   │   ├── ui/              # Basic UI components
│   │   └── mdx/             # MDX-specific components
│   ├── styles/              # Global styles and theme
│   │   ├── globals.css      # Global CSS
│   │   └── theme/          # Theme configuration
│   ├── lib/                 # Utility functions
│   └── providers/          # Context providers
├── content/                # MDX content
│   ├── post/              # Blog posts
│   ├── projects/          # Project documentation
│   └── logs/              # Development logs
└── public/                # Static assets
```

### Benefits of Route Groups

Route groups (directories with parentheses) provide several advantages:

1. **Better Organization**
```typescript
// (routes)/post/[slug]/page.tsx
export default function PostPage({ params }) {
  // Post-specific page logic
}

// (routes)/projects/[slug]/page.tsx
export default function ProjectPage({ params }) {
  // Project-specific page logic
}
```

2. **Shared Layouts**
```typescript
// (routes)/post/layout.tsx
export default function PostLayout({ children }) {
  return (
    <div className="post-layout">
      <PostSidebar />
      {children}
    </div>
  )
}
```

3. **Clean URLs**
- URLs remain clean without the group name
- `/post/typescript-benefits` instead of `/routes/post/typescript-benefits`

4. **Easier Maintenance**
- Related routes are grouped together
- Easier to find and modify related pages
- Better code organization

### Global Styles and Providers

Global styles and providers should be organized in dedicated directories:

```typescript
// src/styles/globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Custom styles */
```

```typescript
// src/providers/theme-provider.tsx
export function ThemeProvider({ children }) {
  return (
    <ThemeContext.Provider value={theme}>
      {children}
    </ThemeContext.Provider>
  )
}
```

Benefits of this organization:
- Clear separation of concerns
- Better maintainability
- Easier to find and modify styles
- Centralized provider management

## TypeScript with ContentLayer: A Perfect Match

ContentLayer takes TypeScript integration to the next level:

```typescript
// contentlayer.config.ts
import { defineDocumentType, makeSource } from 'contentlayer/source-files'

export const Post = defineDocumentType(() => ({
  name: 'Post',
  filePathPattern: 'posts/**/*.mdx',
  contentType: 'mdx',
  fields: {
    title: { type: 'string', required: true },
    date: { type: 'date', required: true },
    description: { type: 'string', required: true },
    tags: { type: 'list', of: { type: 'string' } }
  },
  computedFields: {
    slug: {
      type: 'string',
      resolve: (doc) => doc._raw.sourceFileName.replace(/\.mdx$/, '')
    }
  }
}))

// TypeScript now knows exactly what a Post looks like
const post: Post = {
  title: "TypeScript Benefits",
  date: "2024-03-19",
  description: "Exploring TypeScript benefits",
  tags: ["typescript", "nextjs"],
  slug: "typescript-benefits"
}
```

## Conclusion

TypeScript's benefits in Next.js extend far beyond simple type checking. It provides:
- Enhanced developer experience with intelligent autocomplete
- Catch errors before they reach production
- Better code documentation through types
- Improved maintainability and scalability

When combined with tools like ContentLayer, TypeScript becomes even more powerful, providing type-safe content management and build-time validation.

<Callout type="tip">
  Remember: TypeScript's type checking happens during development and build time, not runtime. This means you get all the benefits without any performance impact in production.
</Callout> 